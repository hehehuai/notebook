# 历程
 1）单进程时代
  不需要调度器 一个进程运行结束后，才能进入下一个进程.
 * 简单
 * 进程阻塞带来cpu资源浪费
 2) 多进程线程时代
  一个进程阻塞cpu，立刻切换到其他进程执行，拥有调度cpu的算法，可以保证在运行的进程都可以被分配到cpu的运行时间片。
  * 解决了公平问题，cpu由于阻塞导致的cpu资源浪费,高内存
  * 进程拥有太多的资源，进程的创建，切换，销毁，会占用很长的时间，cpu占用了很多时间进行进程的调度。
 3) 协程
  用户态线程，cpu不感知用户态线程存在，必须与内核态线程绑定（linux的pcb进程控制块) 我们也叫协程。存在协程和内核线程的关系:
  1) N:1 协程在用户态完成切换，不会陷入内核态，切换非常轻量，这样一个进程的所有协程都绑定在一个线程上。
   * 一旦协程阻塞，造成本线程的所有协程无法执行，没有并发能力
   * 某个程序用不了硬件的多核能力
  2) 1:1 协程的调度都由cpu完成
   * 协程的创建，删除和切换代价由cpu完成，代价有点高
  3) M:N 实现复杂
   线程是cpu抢占式，协程是由户态调度是协作式的，一个协程让出cpu，才可以 
 
 
# golang 协程
 golang 为了提供更容易的并发，使用了goroutine 和channel。 让一组可以复用的函数运行在线程之上，即使有阻塞，该线程的其他协程可以被runtime调度，转移到其他可运行的线程上，程序员可以忽略这些底层细节，降低编程难度，提高更容易的并发。
 golang协程非常轻量，一个goroutine只占用几KB 同时也可以伸缩，调度灵活。
 早期的goroutine调度器 线程M去全局协程队列G获取协程执行
 * 创建、销毁、调度G都需要每个M获取锁，形成激烈竞争。
 * M 转移G会造成延迟和额外的系统负载。比如G创建新协程，为了执行G，需要把新协程交给另外一个M执行，没法利用cpu缓存的局部特性
 * 系统调用会在M之间切换导致频繁的线程阻塞和取消阻塞操作增加了系统开销。
 
 GMP模型
 线程是goroutine运行的实体，调度器的功能是把可运行的goroutine分配到工作线程上。
 P和M何时会创建
 1.P在确定最大数量后，运行时就会根据这个数量创建出来
 2.没有足够的M来关联P并运行其中的可运行的G，比如所有的M都被阻塞了，但是P中还有很多就绪的任务，就会去寻找空虚的M，如果没有空闲的M，就创建。
 * 调度器的设计策略
 复用线程：避免频繁的创建，销毁线程
 1）work stealing机制
 当当前线程无可运行的G，尝试从其他线程绑定的P偷取G，而不是销毁线程
 2） hand off 机制
 当本线程因为G进行系统调用时，线程释放绑定的P，把P转移到其他空闲的线程执行。
 利用并发 GOPMAXPROCS设置P的数量，最多有这么多线程在多个cpu上执行
 抢占 在coroutine要等待一个协程让出cpu才执行下一个协程，在go中，一个goroutine最多占用CPU10ms，防止其他goroutine饿死。
 全局G队列 当P本地队列没有G时，从全局队列获取。
 调度器的生命周期 程序启动后会创建编号为0的主线程，这个M实例会在全局变量runtime.m0中， 不需要在heap上操作，m0负载执行初始化操作和启动第一个G
 每次启动一个M会第一个创建goroutine，G0只是负责调度G，G0不指向可执行的函数，每个M都会有一个G0，在调度和系统调用时会使用G0的栈空间。
 
 参考文献:https://learnku.com/articles/41728
